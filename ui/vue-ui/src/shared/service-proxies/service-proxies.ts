/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.1.3.0 (NJsonSchema v10.0.27.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/operator/finally';
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';

import * as moment from 'moment';

export class ListViewInfoServiceProxy {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    getListViewInfo(name: string | null | undefined): Promise<ListViewInfoDto> {
        let url_ = this.baseUrl + "/listview/ListViewInfo/GetListViewInfo?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetListViewInfo(_response);
        });
    }

    protected processGetListViewInfo(response: AxiosResponse): Promise<ListViewInfoDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListViewInfoDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListViewInfoDto>(<any>null);
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    getFilters(name: string | null | undefined): Promise<PageFilterItemDto[]> {
        let url_ = this.baseUrl + "/listview/ListViewInfo/GetFilters?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetFilters(_response);
        });
    }

    protected processGetFilters(response: AxiosResponse): Promise<PageFilterItemDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PageFilterItemDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PageFilterItemDto[]>(<any>null);
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    getColumns(name: string | null | undefined): Promise<PageColumnItemDto[]> {
        let url_ = this.baseUrl + "/listview/ListViewInfo/GetColumns?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetColumns(_response);
        });
    }

    protected processGetColumns(response: AxiosResponse): Promise<PageColumnItemDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PageColumnItemDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PageColumnItemDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateFilter(body: UpdatePageFiltersInput | undefined): Promise<void> {
        let url_ = this.baseUrl + "/listview/ListViewInfo/UpdateFilter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json", 
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUpdateFilter(_response);
        });
    }

    protected processUpdateFilter(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateColumns(body: UpdatePageColumnsInput | undefined): Promise<void> {
        let url_ = this.baseUrl + "/listview/ListViewInfo/UpdateColumns";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json", 
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUpdateColumns(_response);
        });
    }

    protected processUpdateColumns(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class PermissionServiceProxy {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllPermissions(): Promise<string[]> {
        let url_ = this.baseUrl + "/apis/Permission/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetAllPermissions(_response);
        });
    }

    protected processGetAllPermissions(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPermissionsWithTree(): Promise<PermissionItemDto[]> {
        let url_ = this.baseUrl + "/apis/Permission/GetAllPermissionsWithTree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetAllPermissionsWithTree(_response);
        });
    }

    protected processGetAllPermissionsWithTree(response: AxiosResponse): Promise<PermissionItemDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PermissionItemDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PermissionItemDto[]>(<any>null);
    }
}

export class RoleServiceProxy {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getPage(body: QueryInput | undefined): Promise<RoleDtoPageResultDto> {
        let url_ = this.baseUrl + "/apis/Role/GetPage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetPage(_response);
        });
    }

    protected processGetPage(response: AxiosResponse): Promise<RoleDtoPageResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RoleDtoPageResultDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleDtoPageResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAll(): Promise<RoleDtoListResultDto> {
        let url_ = this.baseUrl + "/apis/Role/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<RoleDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RoleDtoListResultDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleDtoListResultDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getEditById(input: string | undefined): Promise<RoleEditDto> {
        let url_ = this.baseUrl + "/apis/Role/GetEditById?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetEditById(_response);
        });
    }

    protected processGetEditById(response: AxiosResponse): Promise<RoleEditDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RoleEditDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleEditDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateOrUpdateRoleInput | undefined): Promise<void> {
        let url_ = this.baseUrl + "/apis/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json", 
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateOrUpdateRoleInput | undefined): Promise<void> {
        let url_ = this.baseUrl + "/apis/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json", 
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/apis/Role/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json", 
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class SampleEntityServiceProxy {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Promise<SampleEntity[]> {
        let url_ = this.baseUrl + "/apis/SampleEntity/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<SampleEntity[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SampleEntity.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SampleEntity[]>(<any>null);
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    create(name: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/apis/SampleEntity/Create?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/apis/SampleEntity/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class SessionServiceProxy {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentSession(): Promise<SessionDto> {
        let url_ = this.baseUrl + "/apis/Session/GetCurrentSession";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetCurrentSession(_response);
        });
    }

    protected processGetCurrentSession(response: AxiosResponse): Promise<SessionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SessionDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SessionDto>(<any>null);
    }

    /**
     * @return Success
     */
    getLocalization(): Promise<LocalizationDto> {
        let url_ = this.baseUrl + "/apis/Session/GetLocalization";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetLocalization(_response);
        });
    }

    protected processGetLocalization(response: AxiosResponse): Promise<LocalizationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LocalizationDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LocalizationDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAuth(): Promise<AuthDto> {
        let url_ = this.baseUrl + "/apis/Session/GetAuth";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetAuth(_response);
        });
    }

    protected processGetAuth(response: AxiosResponse): Promise<AuthDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuthDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthDto>(<any>null);
    }

    /**
     * @return Success
     */
    getMultiTenancy(): Promise<MultiTenancyDto> {
        let url_ = this.baseUrl + "/apis/Session/GetMultiTenancy";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetMultiTenancy(_response);
        });
    }

    protected processGetMultiTenancy(response: AxiosResponse): Promise<MultiTenancyDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MultiTenancyDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MultiTenancyDto>(<any>null);
    }
}

export class TenantServiceProxy {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Promise<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/apis/Tenant/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processIsTenantAvailable(_response);
        });
    }

    protected processIsTenantAvailable(response: AxiosResponse): Promise<IsTenantAvailableOutput> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getPage(body: QueryInput | undefined): Promise<TenantDtoPageResultDto> {
        let url_ = this.baseUrl + "/apis/Tenant/GetPage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetPage(_response);
        });
    }

    protected processGetPage(response: AxiosResponse): Promise<TenantDtoPageResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TenantDtoPageResultDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TenantDtoPageResultDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getEditById(input: string | undefined): Promise<TenantEditDto> {
        let url_ = this.baseUrl + "/apis/Tenant/GetEditById?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetEditById(_response);
        });
    }

    protected processGetEditById(response: AxiosResponse): Promise<TenantEditDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TenantEditDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TenantEditDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTenantInput | undefined): Promise<void> {
        let url_ = this.baseUrl + "/apis/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json", 
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TenantEditDto | undefined): Promise<void> {
        let url_ = this.baseUrl + "/apis/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json", 
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class TokenAuthServiceProxy {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModelInput | undefined): Promise<AuthenticateResultDto> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processAuthenticate(_response);
        });
    }

    protected processAuthenticate(response: AxiosResponse): Promise<AuthenticateResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuthenticateResultDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthenticateResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    refreshToken(): Promise<AuthenticateResultDto> {
        let url_ = this.baseUrl + "/api/TokenAuth/RefreshToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processRefreshToken(_response);
        });
    }

    protected processRefreshToken(response: AxiosResponse): Promise<AuthenticateResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuthenticateResultDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthenticateResultDto>(<any>null);
    }
}

export class UserServiceProxy {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getPage(body: QueryInput | undefined): Promise<UserDtoPageResultDto> {
        let url_ = this.baseUrl + "/apis/User/GetPage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetPage(_response);
        });
    }

    protected processGetPage(response: AxiosResponse): Promise<UserDtoPageResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDtoPageResultDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDtoPageResultDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getEditById(input: string | undefined): Promise<UserEditDto> {
        let url_ = this.baseUrl + "/apis/User/GetEditById?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetEditById(_response);
        });
    }

    protected processGetEditById(response: AxiosResponse): Promise<UserEditDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserEditDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserEditDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateOrEditUserInput | undefined): Promise<void> {
        let url_ = this.baseUrl + "/apis/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json", 
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateOrEditUserInput | undefined): Promise<void> {
        let url_ = this.baseUrl + "/apis/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json", 
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/apis/User/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json", 
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class PageFilterItemDto implements IPageFilterItemDto {
    field: string | undefined;
    order: number | undefined;
    hidden: boolean;
    width: number;
    xsWidth: number | undefined;
    smWidth: number | undefined;
    mdWidth: number | undefined;
    lgWidth: number | undefined;
    xlWidth: number | undefined;
    xxlWidth: number | undefined;

    constructor(data?: IPageFilterItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.order = _data["order"];
            this.hidden = _data["hidden"];
            this.width = _data["width"];
            this.xsWidth = _data["xsWidth"];
            this.smWidth = _data["smWidth"];
            this.mdWidth = _data["mdWidth"];
            this.lgWidth = _data["lgWidth"];
            this.xlWidth = _data["xlWidth"];
            this.xxlWidth = _data["xxlWidth"];
        }
    }

    static fromJS(data: any): PageFilterItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageFilterItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["order"] = this.order;
        data["hidden"] = this.hidden;
        data["width"] = this.width;
        data["xsWidth"] = this.xsWidth;
        data["smWidth"] = this.smWidth;
        data["mdWidth"] = this.mdWidth;
        data["lgWidth"] = this.lgWidth;
        data["xlWidth"] = this.xlWidth;
        data["xxlWidth"] = this.xxlWidth;
        return data; 
    }

    clone(): PageFilterItemDto {
        const json = this.toJSON();
        let result = new PageFilterItemDto();
        result.init(json);
        return result;
    }
}

export interface IPageFilterItemDto {
    field: string | undefined;
    order: number | undefined;
    hidden: boolean;
    width: number;
    xsWidth: number | undefined;
    smWidth: number | undefined;
    mdWidth: number | undefined;
    lgWidth: number | undefined;
    xlWidth: number | undefined;
    xxlWidth: number | undefined;
}

export class PageColumnItemDto implements IPageColumnItemDto {
    field: string | undefined;
    order: number | undefined;
    width: number | undefined;
    hidden: boolean;

    constructor(data?: IPageColumnItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.order = _data["order"];
            this.width = _data["width"];
            this.hidden = _data["hidden"];
        }
    }

    static fromJS(data: any): PageColumnItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageColumnItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["order"] = this.order;
        data["width"] = this.width;
        data["hidden"] = this.hidden;
        return data; 
    }

    clone(): PageColumnItemDto {
        const json = this.toJSON();
        let result = new PageColumnItemDto();
        result.init(json);
        return result;
    }
}

export interface IPageColumnItemDto {
    field: string | undefined;
    order: number | undefined;
    width: number | undefined;
    hidden: boolean;
}

export class ListViewInfoDto implements IListViewInfoDto {
    filters: PageFilterItemDto[] | undefined;
    columns: PageColumnItemDto[] | undefined;

    constructor(data?: IListViewInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["filters"])) {
                this.filters = [] as any;
                for (let item of _data["filters"])
                    this.filters.push(PageFilterItemDto.fromJS(item));
            }
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(PageColumnItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListViewInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListViewInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.filters)) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListViewInfoDto {
        const json = this.toJSON();
        let result = new ListViewInfoDto();
        result.init(json);
        return result;
    }
}

export interface IListViewInfoDto {
    filters: PageFilterItemDto[] | undefined;
    columns: PageColumnItemDto[] | undefined;
}

export class UpdatePageFiltersInput implements IUpdatePageFiltersInput {
    name: string | undefined;
    filters: PageFilterItemDto[] | undefined;

    constructor(data?: IUpdatePageFiltersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["filters"])) {
                this.filters = [] as any;
                for (let item of _data["filters"])
                    this.filters.push(PageFilterItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdatePageFiltersInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePageFiltersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.filters)) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UpdatePageFiltersInput {
        const json = this.toJSON();
        let result = new UpdatePageFiltersInput();
        result.init(json);
        return result;
    }
}

export interface IUpdatePageFiltersInput {
    name: string | undefined;
    filters: PageFilterItemDto[] | undefined;
}

export class UpdatePageColumnsInput implements IUpdatePageColumnsInput {
    name: string | undefined;
    columns: PageColumnItemDto[] | undefined;

    constructor(data?: IUpdatePageColumnsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(PageColumnItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdatePageColumnsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePageColumnsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UpdatePageColumnsInput {
        const json = this.toJSON();
        let result = new UpdatePageColumnsInput();
        result.init(json);
        return result;
    }
}

export interface IUpdatePageColumnsInput {
    name: string | undefined;
    columns: PageColumnItemDto[] | undefined;
}

export class PermissionItemDto implements IPermissionItemDto {
    parent: string | undefined;
    name: string | undefined;
    sort: number;

    constructor(data?: IPermissionItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parent = _data["parent"];
            this.name = _data["name"];
            this.sort = _data["sort"];
        }
    }

    static fromJS(data: any): PermissionItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parent"] = this.parent;
        data["name"] = this.name;
        data["sort"] = this.sort;
        return data; 
    }

    clone(): PermissionItemDto {
        const json = this.toJSON();
        let result = new PermissionItemDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionItemDto {
    parent: string | undefined;
    name: string | undefined;
    sort: number;
}

export enum QueryOperator {
    Equal = <any>"Equal",
    NotEqual = <any>"NotEqual",
    Greater = <any>"Greater",
    GreaterEqual = <any>"GreaterEqual",
    Less = <any>"Less",
    LessEqual = <any>"LessEqual",
    StartsWith = <any>"StartsWith",
    EndsWith = <any>"EndsWith",
    In = <any>"In",
    NotIn = <any>"NotIn",
    Contains = <any>"Contains",
    Between = <any>"Between",
    BetweenEqualStart = <any>"BetweenEqualStart",
    BetweenEqualEnd = <any>"BetweenEqualEnd",
    BetweenEqualStartAndEnd = <any>"BetweenEqualStartAndEnd",
}

export class QueryCondition implements IQueryCondition {
    field: string | undefined;
    value: string | undefined;
    operator: QueryOperator;
    skipValueIsNull: boolean;

    constructor(data?: IQueryCondition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.value = _data["value"];
            this.operator = _data["operator"];
            this.skipValueIsNull = _data["skipValueIsNull"];
        }
    }

    static fromJS(data: any): QueryCondition {
        data = typeof data === 'object' ? data : {};
        let result = new QueryCondition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["value"] = this.value;
        data["operator"] = this.operator;
        data["skipValueIsNull"] = this.skipValueIsNull;
        return data; 
    }

    clone(): QueryCondition {
        const json = this.toJSON();
        let result = new QueryCondition();
        result.init(json);
        return result;
    }
}

export interface IQueryCondition {
    field: string | undefined;
    value: string | undefined;
    operator: QueryOperator;
    skipValueIsNull: boolean;
}

export enum SortType {
    None = <any>"None",
    Asc = <any>"Asc",
    Desc = <any>"Desc",
}

export class SortCondition implements ISortCondition {
    field: string | undefined;
    order: number;
    type: SortType;

    constructor(data?: ISortCondition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.order = _data["order"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): SortCondition {
        data = typeof data === 'object' ? data : {};
        let result = new SortCondition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["order"] = this.order;
        data["type"] = this.type;
        return data; 
    }

    clone(): SortCondition {
        const json = this.toJSON();
        let result = new SortCondition();
        result.init(json);
        return result;
    }
}

export interface ISortCondition {
    field: string | undefined;
    order: number;
    type: SortType;
}

export class QueryInput implements IQueryInput {
    pageSize: number;
    skipCount: number;
    queryConditions: QueryCondition[] | undefined;
    sortConditions: SortCondition[] | undefined;

    constructor(data?: IQueryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"];
            this.skipCount = _data["skipCount"];
            if (Array.isArray(_data["queryConditions"])) {
                this.queryConditions = [] as any;
                for (let item of _data["queryConditions"])
                    this.queryConditions.push(QueryCondition.fromJS(item));
            }
            if (Array.isArray(_data["sortConditions"])) {
                this.sortConditions = [] as any;
                for (let item of _data["sortConditions"])
                    this.sortConditions.push(SortCondition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QueryInput {
        data = typeof data === 'object' ? data : {};
        let result = new QueryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        if (Array.isArray(this.queryConditions)) {
            data["queryConditions"] = [];
            for (let item of this.queryConditions)
                data["queryConditions"].push(item.toJSON());
        }
        if (Array.isArray(this.sortConditions)) {
            data["sortConditions"] = [];
            for (let item of this.sortConditions)
                data["sortConditions"].push(item.toJSON());
        }
        return data; 
    }

    clone(): QueryInput {
        const json = this.toJSON();
        let result = new QueryInput();
        result.init(json);
        return result;
    }
}

export interface IQueryInput {
    pageSize: number;
    skipCount: number;
    queryConditions: QueryCondition[] | undefined;
    sortConditions: SortCondition[] | undefined;
}

export class RoleDto implements IRoleDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isStatic: boolean;
    id: string | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isStatic = _data["isStatic"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isStatic: boolean;
    id: string | undefined;
}

export class RoleDtoPageResultDto implements IRoleDtoPageResultDto {
    items: RoleDto[] | undefined;
    total: number;

    constructor(data?: IRoleDtoPageResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): RoleDtoPageResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoPageResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }

    clone(): RoleDtoPageResultDto {
        const json = this.toJSON();
        let result = new RoleDtoPageResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoPageResultDto {
    items: RoleDto[] | undefined;
    total: number;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoListResultDto {
    items: RoleDto[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    entityDto: RoleDto;
    permissions: string[] | undefined;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityDto = _data["entityDto"] ? RoleDto.fromJS(_data["entityDto"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(item);
            }
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityDto"] = this.entityDto ? this.entityDto.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data; 
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    entityDto: RoleDto;
    permissions: string[] | undefined;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
    entityDto: RoleDto;
    permissions: string[] | undefined;

    constructor(data?: ICreateOrUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityDto = _data["entityDto"] ? RoleDto.fromJS(_data["entityDto"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityDto"] = this.entityDto ? this.entityDto.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data; 
    }

    clone(): CreateOrUpdateRoleInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateRoleInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateRoleInput {
    entityDto: RoleDto;
    permissions: string[] | undefined;
}

export class SampleEntity implements ISampleEntity {
    displayName: string | undefined;
    id: number;

    constructor(data?: ISampleEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SampleEntity {
        data = typeof data === 'object' ? data : {};
        let result = new SampleEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["id"] = this.id;
        return data; 
    }

    clone(): SampleEntity {
        const json = this.toJSON();
        let result = new SampleEntity();
        result.init(json);
        return result;
    }
}

export interface ISampleEntity {
    displayName: string | undefined;
    id: number;
}

export class MultiTenancyDto implements IMultiTenancyDto {
    isEnabled: boolean;
    name: string | undefined;
    displayName: string | undefined;

    constructor(data?: IMultiTenancyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): MultiTenancyDto {
        data = typeof data === 'object' ? data : {};
        let result = new MultiTenancyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone(): MultiTenancyDto {
        const json = this.toJSON();
        let result = new MultiTenancyDto();
        result.init(json);
        return result;
    }
}

export interface IMultiTenancyDto {
    isEnabled: boolean;
    name: string | undefined;
    displayName: string | undefined;
}

export class AuthDto implements IAuthDto {
    userId: string | undefined;
    userName: string | undefined;
    userNickName: string | undefined;
    allPermissions: string[] | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: IAuthDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.userNickName = _data["userNickName"];
            if (Array.isArray(_data["allPermissions"])) {
                this.allPermissions = [] as any;
                for (let item of _data["allPermissions"])
                    this.allPermissions.push(item);
            }
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): AuthDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["userNickName"] = this.userNickName;
        if (Array.isArray(this.allPermissions)) {
            data["allPermissions"] = [];
            for (let item of this.allPermissions)
                data["allPermissions"].push(item);
        }
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data; 
    }

    clone(): AuthDto {
        const json = this.toJSON();
        let result = new AuthDto();
        result.init(json);
        return result;
    }
}

export interface IAuthDto {
    userId: string | undefined;
    userName: string | undefined;
    userNickName: string | undefined;
    allPermissions: string[] | undefined;
    grantedPermissions: string[] | undefined;
}

export class LanguageInfoDto implements ILanguageInfoDto {
    culture: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    extra: string | undefined;
    texts: { [key: string]: string; } | undefined;

    constructor(data?: ILanguageInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.culture = _data["culture"];
            this.displayName = _data["displayName"];
            this.icon = _data["icon"];
            this.extra = _data["extra"];
            if (_data["texts"]) {
                this.texts = {} as any;
                for (let key in _data["texts"]) {
                    if (_data["texts"].hasOwnProperty(key))
                        this.texts[key] = _data["texts"][key];
                }
            }
        }
    }

    static fromJS(data: any): LanguageInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["culture"] = this.culture;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["extra"] = this.extra;
        if (this.texts) {
            data["texts"] = {};
            for (let key in this.texts) {
                if (this.texts.hasOwnProperty(key))
                    data["texts"][key] = this.texts[key];
            }
        }
        return data; 
    }

    clone(): LanguageInfoDto {
        const json = this.toJSON();
        let result = new LanguageInfoDto();
        result.init(json);
        return result;
    }
}

export interface ILanguageInfoDto {
    culture: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    extra: string | undefined;
    texts: { [key: string]: string; } | undefined;
}

export class LocalizationDto implements ILocalizationDto {
    defaultCulture: string | undefined;
    currentCulture: string | undefined;
    languages: LanguageInfoDto[] | undefined;

    constructor(data?: ILocalizationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultCulture = _data["defaultCulture"];
            this.currentCulture = _data["currentCulture"];
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages.push(LanguageInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizationDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultCulture"] = this.defaultCulture;
        data["currentCulture"] = this.currentCulture;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        return data; 
    }

    clone(): LocalizationDto {
        const json = this.toJSON();
        let result = new LocalizationDto();
        result.init(json);
        return result;
    }
}

export interface ILocalizationDto {
    defaultCulture: string | undefined;
    currentCulture: string | undefined;
    languages: LanguageInfoDto[] | undefined;
}

export class SessionDto implements ISessionDto {
    name: string | undefined;
    displayName: string | undefined;
    version: string | undefined;
    multiTenancy: MultiTenancyDto;
    auth: AuthDto;
    localization: LocalizationDto;
    menu: string | undefined;

    constructor(data?: ISessionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.version = _data["version"];
            this.multiTenancy = _data["multiTenancy"] ? MultiTenancyDto.fromJS(_data["multiTenancy"]) : <any>undefined;
            this.auth = _data["auth"] ? AuthDto.fromJS(_data["auth"]) : <any>undefined;
            this.localization = _data["localization"] ? LocalizationDto.fromJS(_data["localization"]) : <any>undefined;
            this.menu = _data["menu"];
        }
    }

    static fromJS(data: any): SessionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SessionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["version"] = this.version;
        data["multiTenancy"] = this.multiTenancy ? this.multiTenancy.toJSON() : <any>undefined;
        data["auth"] = this.auth ? this.auth.toJSON() : <any>undefined;
        data["localization"] = this.localization ? this.localization.toJSON() : <any>undefined;
        data["menu"] = this.menu;
        return data; 
    }

    clone(): SessionDto {
        const json = this.toJSON();
        let result = new SessionDto();
        result.init(json);
        return result;
    }
}

export interface ISessionDto {
    name: string | undefined;
    displayName: string | undefined;
    version: string | undefined;
    multiTenancy: MultiTenancyDto;
    auth: AuthDto;
    localization: LocalizationDto;
    menu: string | undefined;
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenantName: string | undefined;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantName = _data["tenantName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        return data; 
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenantName: string | undefined;
}

export enum TenantAvailabilityState {
    Available = <any>"Available",
    InActive = <any>"InActive",
    NotFound = <any>"NotFound",
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantName: string | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantName = _data["tenantName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantName"] = this.tenantName;
        return data; 
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantName: string | undefined;
}

export class TenantDto implements ITenantDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    connectionString: string | undefined;
    isStatic: boolean;
    isActive: boolean;
    id: string | undefined;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.connectionString = _data["connectionString"];
            this.isStatic = _data["isStatic"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["connectionString"] = this.connectionString;
        data["isStatic"] = this.isStatic;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    connectionString: string | undefined;
    isStatic: boolean;
    isActive: boolean;
    id: string | undefined;
}

export class TenantDtoPageResultDto implements ITenantDtoPageResultDto {
    items: TenantDto[] | undefined;
    total: number;

    constructor(data?: ITenantDtoPageResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): TenantDtoPageResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPageResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }

    clone(): TenantDtoPageResultDto {
        const json = this.toJSON();
        let result = new TenantDtoPageResultDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDtoPageResultDto {
    items: TenantDto[] | undefined;
    total: number;
}

export class TenantEditDto implements ITenantEditDto {
    entityDto: TenantDto;

    constructor(data?: ITenantEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityDto = _data["entityDto"] ? TenantDto.fromJS(_data["entityDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityDto"] = this.entityDto ? this.entityDto.toJSON() : <any>undefined;
        return data; 
    }

    clone(): TenantEditDto {
        const json = this.toJSON();
        let result = new TenantEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantEditDto {
    entityDto: TenantDto;
}

export class CreateTenantInput implements ICreateTenantInput {
    adminUser: string | undefined;
    adminUserPassword: string | undefined;
    adminUserEmail: string | undefined;
    adminUserPhoneNumber: string | undefined;
    entityDto: TenantDto;

    constructor(data?: ICreateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adminUser = _data["adminUser"];
            this.adminUserPassword = _data["adminUserPassword"];
            this.adminUserEmail = _data["adminUserEmail"];
            this.adminUserPhoneNumber = _data["adminUserPhoneNumber"];
            this.entityDto = _data["entityDto"] ? TenantDto.fromJS(_data["entityDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminUser"] = this.adminUser;
        data["adminUserPassword"] = this.adminUserPassword;
        data["adminUserEmail"] = this.adminUserEmail;
        data["adminUserPhoneNumber"] = this.adminUserPhoneNumber;
        data["entityDto"] = this.entityDto ? this.entityDto.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateTenantInput {
        const json = this.toJSON();
        let result = new CreateTenantInput();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantInput {
    adminUser: string | undefined;
    adminUserPassword: string | undefined;
    adminUserEmail: string | undefined;
    adminUserPhoneNumber: string | undefined;
    entityDto: TenantDto;
}

export class AuthenticateModelInput implements IAuthenticateModelInput {
    account: string | undefined;
    password: string | undefined;
    verificationCode: string | undefined;
    rememberClient: boolean;
    returnUrl: string | undefined;
    useCookie: boolean;
    useToken: boolean;

    constructor(data?: IAuthenticateModelInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.account = _data["account"];
            this.password = _data["password"];
            this.verificationCode = _data["verificationCode"];
            this.rememberClient = _data["rememberClient"];
            this.returnUrl = _data["returnUrl"];
            this.useCookie = _data["useCookie"];
            this.useToken = _data["useToken"];
        }
    }

    static fromJS(data: any): AuthenticateModelInput {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModelInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account;
        data["password"] = this.password;
        data["verificationCode"] = this.verificationCode;
        data["rememberClient"] = this.rememberClient;
        data["returnUrl"] = this.returnUrl;
        data["useCookie"] = this.useCookie;
        data["useToken"] = this.useToken;
        return data; 
    }

    clone(): AuthenticateModelInput {
        const json = this.toJSON();
        let result = new AuthenticateModelInput();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModelInput {
    account: string | undefined;
    password: string | undefined;
    verificationCode: string | undefined;
    rememberClient: boolean;
    returnUrl: string | undefined;
    useCookie: boolean;
    useToken: boolean;
}

export class AuthenticateResultDto implements IAuthenticateResultDto {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
    shouldResetPassword: boolean;
    passwordResetCode: string | undefined;
    returnUrl: string | undefined;
    waitingForActivation: boolean;

    constructor(data?: IAuthenticateResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
            this.shouldResetPassword = _data["shouldResetPassword"];
            this.passwordResetCode = _data["passwordResetCode"];
            this.returnUrl = _data["returnUrl"];
            this.waitingForActivation = _data["waitingForActivation"];
        }
    }

    static fromJS(data: any): AuthenticateResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["returnUrl"] = this.returnUrl;
        data["waitingForActivation"] = this.waitingForActivation;
        return data; 
    }

    clone(): AuthenticateResultDto {
        const json = this.toJSON();
        let result = new AuthenticateResultDto();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultDto {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
    shouldResetPassword: boolean;
    passwordResetCode: string | undefined;
    returnUrl: string | undefined;
    waitingForActivation: boolean;
}

export class UserDto implements IUserDto {
    userName: string | undefined;
    nickname: string | undefined;
    phoneNumber: string | undefined;
    phoneNumberConfirmed: boolean;
    email: string | undefined;
    emailConfirmed: boolean;
    lockoutEnabled: boolean;
    isActive: boolean;
    twoFactorEnabled: boolean;
    isStatic: boolean;
    id: string | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.nickname = _data["nickname"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.email = _data["email"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.isActive = _data["isActive"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.isStatic = _data["isStatic"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["nickname"] = this.nickname;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["email"] = this.email;
        data["emailConfirmed"] = this.emailConfirmed;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["isActive"] = this.isActive;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["isStatic"] = this.isStatic;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    userName: string | undefined;
    nickname: string | undefined;
    phoneNumber: string | undefined;
    phoneNumberConfirmed: boolean;
    email: string | undefined;
    emailConfirmed: boolean;
    lockoutEnabled: boolean;
    isActive: boolean;
    twoFactorEnabled: boolean;
    isStatic: boolean;
    id: string | undefined;
}

export class UserDtoPageResultDto implements IUserDtoPageResultDto {
    items: UserDto[] | undefined;
    total: number;

    constructor(data?: IUserDtoPageResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): UserDtoPageResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPageResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }

    clone(): UserDtoPageResultDto {
        const json = this.toJSON();
        let result = new UserDtoPageResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserDtoPageResultDto {
    items: UserDto[] | undefined;
    total: number;
}

export class UserEditDto implements IUserEditDto {
    entityDto: UserDto;
    roles: string[] | undefined;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityDto = _data["entityDto"] ? UserDto.fromJS(_data["entityDto"]) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles.push(item);
            }
        }
    }

    static fromJS(data: any): UserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityDto"] = this.entityDto ? this.entityDto.toJSON() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }

    clone(): UserEditDto {
        const json = this.toJSON();
        let result = new UserEditDto();
        result.init(json);
        return result;
    }
}

export interface IUserEditDto {
    entityDto: UserDto;
    roles: string[] | undefined;
}

export class CreateOrEditUserInput implements ICreateOrEditUserInput {
    password: string | undefined;
    entityDto: UserDto;
    roles: string[] | undefined;

    constructor(data?: ICreateOrEditUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
            this.entityDto = _data["entityDto"] ? UserDto.fromJS(_data["entityDto"]) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrEditUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["entityDto"] = this.entityDto ? this.entityDto.toJSON() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }

    clone(): CreateOrEditUserInput {
        const json = this.toJSON();
        let result = new CreateOrEditUserInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditUserInput {
    password: string | undefined;
    entityDto: UserDto;
    roles: string[] | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}

//