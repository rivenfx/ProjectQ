/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.3.0.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class DynamicPageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    getDynamicPageInfo(name: string | null | undefined): Observable<DynamicPageDto> {
        let url_ = this.baseUrl + "/apis/DynamicPage/GetDynamicPageInfo?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDynamicPageInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDynamicPageInfo(<any>response_);
                } catch (e) {
                    return <Observable<DynamicPageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DynamicPageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDynamicPageInfo(response: HttpResponseBase): Observable<DynamicPageDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicPageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicPageDto>(<any>null);
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    getPageFilters(name: string | null | undefined): Observable<PageFilterItemDtoListResultDto> {
        let url_ = this.baseUrl + "/apis/DynamicPage/GetPageFilters?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPageFilters(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPageFilters(<any>response_);
                } catch (e) {
                    return <Observable<PageFilterItemDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageFilterItemDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPageFilters(response: HttpResponseBase): Observable<PageFilterItemDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageFilterItemDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageFilterItemDtoListResultDto>(<any>null);
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    getColumns(name: string | null | undefined): Observable<ColumnItemDtoListResultDto> {
        let url_ = this.baseUrl + "/apis/DynamicPage/GetColumns?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetColumns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetColumns(<any>response_);
                } catch (e) {
                    return <Observable<ColumnItemDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ColumnItemDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetColumns(response: HttpResponseBase): Observable<ColumnItemDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ColumnItemDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ColumnItemDtoListResultDto>(<any>null);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<string[]> {
        let url_ = this.baseUrl + "/apis/Permission/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPermissionsWithTree(): Observable<PermissionItemDto[]> {
        let url_ = this.baseUrl + "/apis/Permission/GetAllPermissionsWithTree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissionsWithTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissionsWithTree(<any>response_);
                } catch (e) {
                    return <Observable<PermissionItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissionsWithTree(response: HttpResponseBase): Observable<PermissionItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PermissionItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionItemDto[]>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getPage(body: QueryInput | undefined): Observable<RoleDtoPageResultDto> {
        let url_ = this.baseUrl + "/apis/Role/GetPage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPage(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoPageResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoPageResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPage(response: HttpResponseBase): Observable<RoleDtoPageResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPageResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoPageResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAll(): Observable<RoleDtoListResultDto> {
        let url_ = this.baseUrl + "/apis/Role/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RoleDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoListResultDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getEditById(input: string | undefined): Observable<RoleEditDto> {
        let url_ = this.baseUrl + "/apis/Role/GetEditById?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditById(<any>response_);
                } catch (e) {
                    return <Observable<RoleEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditById(response: HttpResponseBase): Observable<RoleEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleEditDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateOrUpdateRoleInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/apis/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateOrUpdateRoleInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/apis/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/apis/Role/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SampleEntityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<SampleEntity[]> {
        let url_ = this.baseUrl + "/apis/SampleEntity/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<SampleEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SampleEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SampleEntity[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SampleEntity.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SampleEntity[]>(<any>null);
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    create(name: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/apis/SampleEntity/Create?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/apis/SampleEntity/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentSession(): Observable<SessionDto> {
        let url_ = this.baseUrl + "/apis/Session/GetCurrentSession";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentSession(<any>response_);
                } catch (e) {
                    return <Observable<SessionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SessionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentSession(response: HttpResponseBase): Observable<SessionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SessionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SessionDto>(<any>null);
    }

    /**
     * @return Success
     */
    getLocalization(): Observable<LocalizationDto> {
        let url_ = this.baseUrl + "/apis/Session/GetLocalization";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocalization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocalization(<any>response_);
                } catch (e) {
                    return <Observable<LocalizationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocalizationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLocalization(response: HttpResponseBase): Observable<LocalizationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocalizationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocalizationDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAuth(): Observable<AuthDto> {
        let url_ = this.baseUrl + "/apis/Session/GetAuth";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuth(<any>response_);
                } catch (e) {
                    return <Observable<AuthDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuth(response: HttpResponseBase): Observable<AuthDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthDto>(<any>null);
    }

    /**
     * @return Success
     */
    getMultiTenancy(): Observable<MultiTenancyDto> {
        let url_ = this.baseUrl + "/apis/Session/GetMultiTenancy";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMultiTenancy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMultiTenancy(<any>response_);
                } catch (e) {
                    return <Observable<MultiTenancyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MultiTenancyDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMultiTenancy(response: HttpResponseBase): Observable<MultiTenancyDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MultiTenancyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MultiTenancyDto>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/apis/Tenant/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getPage(body: QueryInput | undefined): Observable<TenantDtoPageResultDto> {
        let url_ = this.baseUrl + "/apis/Tenant/GetPage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPage(<any>response_);
                } catch (e) {
                    return <Observable<TenantDtoPageResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDtoPageResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPage(response: HttpResponseBase): Observable<TenantDtoPageResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDtoPageResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDtoPageResultDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getEditById(input: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/apis/Tenant/GetEditById?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditById(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateTenantInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/apis/Tenant/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModelInput | undefined): Observable<AuthenticateResultDto> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    refreshToken(): Observable<AuthenticateResultDto> {
        let url_ = this.baseUrl + "/api/TokenAuth/RefreshToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<AuthenticateResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultDto>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getPage(body: QueryInput | undefined): Observable<UserDtoPageResultDto> {
        let url_ = this.baseUrl + "/apis/User/GetPage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPage(<any>response_);
                } catch (e) {
                    return <Observable<UserDtoPageResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDtoPageResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPage(response: HttpResponseBase): Observable<UserDtoPageResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPageResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoPageResultDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getEditById(input: string | undefined): Observable<UserEditDto> {
        let url_ = this.baseUrl + "/apis/User/GetEditById?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditById(<any>response_);
                } catch (e) {
                    return <Observable<UserEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditById(response: HttpResponseBase): Observable<UserEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserEditDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateOrEditUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/apis/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CreateOrEditUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/apis/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/apis/User/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export enum QueryOperator {
    Equal = <any>"Equal",
    NotEqual = <any>"NotEqual",
    Greater = <any>"Greater",
    GreaterEqual = <any>"GreaterEqual",
    Less = <any>"Less",
    LessEqual = <any>"LessEqual",
    StartsWith = <any>"StartsWith",
    EndsWith = <any>"EndsWith",
    In = <any>"In",
    NotIn = <any>"NotIn",
    Contains = <any>"Contains",
    Between = <any>"Between",
    BetweenEqualStart = <any>"BetweenEqualStart",
    BetweenEqualEnd = <any>"BetweenEqualEnd",
    BetweenEqualStartAndEnd = <any>"BetweenEqualStartAndEnd",
}

export class PageFilterItemDto implements IPageFilterItemDto {
    order: number;
    label: string | undefined;
    componentName: string | undefined;
    args: { [key: string]: any; } | undefined;
    valueChange: string[] | undefined;
    enabled: boolean;
    width: number;
    xsWidth: number | undefined;
    smWidth: number | undefined;
    mdWidth: number | undefined;
    lgWidth: number | undefined;
    xlWidth: number | undefined;
    xxlWidth: number | undefined;
    field: string | undefined;
    value: string | undefined;
    operator: QueryOperator;
    skipValueIsNull: boolean;

    constructor(data?: IPageFilterItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.order = _data["order"];
            this.label = _data["label"];
            this.componentName = _data["componentName"];
            if (_data["args"]) {
                this.args = {} as any;
                for (let key in _data["args"]) {
                    if (_data["args"].hasOwnProperty(key))
                        this.args[key] = _data["args"][key];
                }
            }
            if (Array.isArray(_data["valueChange"])) {
                this.valueChange = [] as any;
                for (let item of _data["valueChange"])
                    this.valueChange.push(item);
            }
            this.enabled = _data["enabled"];
            this.width = _data["width"];
            this.xsWidth = _data["xsWidth"];
            this.smWidth = _data["smWidth"];
            this.mdWidth = _data["mdWidth"];
            this.lgWidth = _data["lgWidth"];
            this.xlWidth = _data["xlWidth"];
            this.xxlWidth = _data["xxlWidth"];
            this.field = _data["field"];
            this.value = _data["value"];
            this.operator = _data["operator"];
            this.skipValueIsNull = _data["skipValueIsNull"];
        }
    }

    static fromJS(data: any): PageFilterItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageFilterItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["order"] = this.order;
        data["label"] = this.label;
        data["componentName"] = this.componentName;
        if (this.args) {
            data["args"] = {};
            for (let key in this.args) {
                if (this.args.hasOwnProperty(key))
                    data["args"][key] = this.args[key];
            }
        }
        if (Array.isArray(this.valueChange)) {
            data["valueChange"] = [];
            for (let item of this.valueChange)
                data["valueChange"].push(item);
        }
        data["enabled"] = this.enabled;
        data["width"] = this.width;
        data["xsWidth"] = this.xsWidth;
        data["smWidth"] = this.smWidth;
        data["mdWidth"] = this.mdWidth;
        data["lgWidth"] = this.lgWidth;
        data["xlWidth"] = this.xlWidth;
        data["xxlWidth"] = this.xxlWidth;
        data["field"] = this.field;
        data["value"] = this.value;
        data["operator"] = this.operator;
        data["skipValueIsNull"] = this.skipValueIsNull;
        return data; 
    }

    clone(): PageFilterItemDto {
        const json = this.toJSON();
        let result = new PageFilterItemDto();
        result.init(json);
        return result;
    }
}

export interface IPageFilterItemDto {
    order: number;
    label: string | undefined;
    componentName: string | undefined;
    args: { [key: string]: any; } | undefined;
    valueChange: string[] | undefined;
    enabled: boolean;
    width: number;
    xsWidth: number | undefined;
    smWidth: number | undefined;
    mdWidth: number | undefined;
    lgWidth: number | undefined;
    xlWidth: number | undefined;
    xxlWidth: number | undefined;
    field: string | undefined;
    value: string | undefined;
    operator: QueryOperator;
    skipValueIsNull: boolean;
}

export enum ColumnItemStatistical {
    None = <any>"None",
    Count = <any>"Count",
    DistinctCount = <any>"DistinctCount",
    Sum = <any>"Sum",
    Average = <any>"Average",
    Max = <any>"Max",
    Min = <any>"Min",
}

export enum ColumnItemFixed {
    None = <any>"None",
    Left = <any>"Left",
    Right = <any>"Right",
}

export enum ColumnControl {
    Button = <any>"Button",
    Select = <any>"Select",
}

export class ColumnActionItemDto implements IColumnActionItemDto {
    name: string | undefined;
    label: string | undefined;
    icon: string | undefined;
    type: ColumnControl;
    acl: string | undefined;
    buttons: ColumnActionItemDto[] | undefined;

    constructor(data?: IColumnActionItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.label = _data["label"];
            this.icon = _data["icon"];
            this.type = _data["type"];
            this.acl = _data["acl"];
            if (Array.isArray(_data["buttons"])) {
                this.buttons = [] as any;
                for (let item of _data["buttons"])
                    this.buttons.push(ColumnActionItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ColumnActionItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ColumnActionItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["label"] = this.label;
        data["icon"] = this.icon;
        data["type"] = this.type;
        data["acl"] = this.acl;
        if (Array.isArray(this.buttons)) {
            data["buttons"] = [];
            for (let item of this.buttons)
                data["buttons"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ColumnActionItemDto {
        const json = this.toJSON();
        let result = new ColumnActionItemDto();
        result.init(json);
        return result;
    }
}

export interface IColumnActionItemDto {
    name: string | undefined;
    label: string | undefined;
    icon: string | undefined;
    type: ColumnControl;
    acl: string | undefined;
    buttons: ColumnActionItemDto[] | undefined;
}

export class ColumnItemDto implements IColumnItemDto {
    field: string | undefined;
    type: string | undefined;
    title: string | undefined;
    render: string | undefined;
    order: number | undefined;
    width: number | undefined;
    numberDigits: number;
    dateFormat: string | undefined;
    statistical: ColumnItemStatistical;
    fixed: ColumnItemFixed;
    actions: ColumnActionItemDto[] | undefined;

    constructor(data?: IColumnItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.type = _data["type"];
            this.title = _data["title"];
            this.render = _data["render"];
            this.order = _data["order"];
            this.width = _data["width"];
            this.numberDigits = _data["numberDigits"];
            this.dateFormat = _data["dateFormat"];
            this.statistical = _data["statistical"];
            this.fixed = _data["fixed"];
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions.push(ColumnActionItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ColumnItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ColumnItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["type"] = this.type;
        data["title"] = this.title;
        data["render"] = this.render;
        data["order"] = this.order;
        data["width"] = this.width;
        data["numberDigits"] = this.numberDigits;
        data["dateFormat"] = this.dateFormat;
        data["statistical"] = this.statistical;
        data["fixed"] = this.fixed;
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ColumnItemDto {
        const json = this.toJSON();
        let result = new ColumnItemDto();
        result.init(json);
        return result;
    }
}

export interface IColumnItemDto {
    field: string | undefined;
    type: string | undefined;
    title: string | undefined;
    render: string | undefined;
    order: number | undefined;
    width: number | undefined;
    numberDigits: number;
    dateFormat: string | undefined;
    statistical: ColumnItemStatistical;
    fixed: ColumnItemFixed;
    actions: ColumnActionItemDto[] | undefined;
}

export class DynamicPageDto implements IDynamicPageDto {
    pageFilters: PageFilterItemDto[] | undefined;
    columns: ColumnItemDto[] | undefined;

    constructor(data?: IDynamicPageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["pageFilters"])) {
                this.pageFilters = [] as any;
                for (let item of _data["pageFilters"])
                    this.pageFilters.push(PageFilterItemDto.fromJS(item));
            }
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(ColumnItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DynamicPageDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.pageFilters)) {
            data["pageFilters"] = [];
            for (let item of this.pageFilters)
                data["pageFilters"].push(item.toJSON());
        }
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DynamicPageDto {
        const json = this.toJSON();
        let result = new DynamicPageDto();
        result.init(json);
        return result;
    }
}

export interface IDynamicPageDto {
    pageFilters: PageFilterItemDto[] | undefined;
    columns: ColumnItemDto[] | undefined;
}

export class PageFilterItemDtoListResultDto implements IPageFilterItemDtoListResultDto {
    items: PageFilterItemDto[] | undefined;

    constructor(data?: IPageFilterItemDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PageFilterItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageFilterItemDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageFilterItemDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PageFilterItemDtoListResultDto {
        const json = this.toJSON();
        let result = new PageFilterItemDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IPageFilterItemDtoListResultDto {
    items: PageFilterItemDto[] | undefined;
}

export class ColumnItemDtoListResultDto implements IColumnItemDtoListResultDto {
    items: ColumnItemDto[] | undefined;

    constructor(data?: IColumnItemDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ColumnItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ColumnItemDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ColumnItemDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ColumnItemDtoListResultDto {
        const json = this.toJSON();
        let result = new ColumnItemDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IColumnItemDtoListResultDto {
    items: ColumnItemDto[] | undefined;
}

export class PermissionItemDto implements IPermissionItemDto {
    parent: string | undefined;
    name: string | undefined;
    sort: number;

    constructor(data?: IPermissionItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parent = _data["parent"];
            this.name = _data["name"];
            this.sort = _data["sort"];
        }
    }

    static fromJS(data: any): PermissionItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parent"] = this.parent;
        data["name"] = this.name;
        data["sort"] = this.sort;
        return data; 
    }

    clone(): PermissionItemDto {
        const json = this.toJSON();
        let result = new PermissionItemDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionItemDto {
    parent: string | undefined;
    name: string | undefined;
    sort: number;
}

export class QueryCondition implements IQueryCondition {
    field: string | undefined;
    value: string | undefined;
    operator: QueryOperator;
    skipValueIsNull: boolean;

    constructor(data?: IQueryCondition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.value = _data["value"];
            this.operator = _data["operator"];
            this.skipValueIsNull = _data["skipValueIsNull"];
        }
    }

    static fromJS(data: any): QueryCondition {
        data = typeof data === 'object' ? data : {};
        let result = new QueryCondition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["value"] = this.value;
        data["operator"] = this.operator;
        data["skipValueIsNull"] = this.skipValueIsNull;
        return data; 
    }

    clone(): QueryCondition {
        const json = this.toJSON();
        let result = new QueryCondition();
        result.init(json);
        return result;
    }
}

export interface IQueryCondition {
    field: string | undefined;
    value: string | undefined;
    operator: QueryOperator;
    skipValueIsNull: boolean;
}

export enum SortType {
    None = <any>"None",
    Asc = <any>"Asc",
    Desc = <any>"Desc",
}

export class SortCondition implements ISortCondition {
    field: string | undefined;
    order: number;
    type: SortType;

    constructor(data?: ISortCondition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.order = _data["order"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): SortCondition {
        data = typeof data === 'object' ? data : {};
        let result = new SortCondition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["order"] = this.order;
        data["type"] = this.type;
        return data; 
    }

    clone(): SortCondition {
        const json = this.toJSON();
        let result = new SortCondition();
        result.init(json);
        return result;
    }
}

export interface ISortCondition {
    field: string | undefined;
    order: number;
    type: SortType;
}

export class QueryInput implements IQueryInput {
    pageSize: number;
    skipCount: number;
    queryConditions: QueryCondition[] | undefined;
    sortConditions: SortCondition[] | undefined;

    constructor(data?: IQueryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"];
            this.skipCount = _data["skipCount"];
            if (Array.isArray(_data["queryConditions"])) {
                this.queryConditions = [] as any;
                for (let item of _data["queryConditions"])
                    this.queryConditions.push(QueryCondition.fromJS(item));
            }
            if (Array.isArray(_data["sortConditions"])) {
                this.sortConditions = [] as any;
                for (let item of _data["sortConditions"])
                    this.sortConditions.push(SortCondition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QueryInput {
        data = typeof data === 'object' ? data : {};
        let result = new QueryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        if (Array.isArray(this.queryConditions)) {
            data["queryConditions"] = [];
            for (let item of this.queryConditions)
                data["queryConditions"].push(item.toJSON());
        }
        if (Array.isArray(this.sortConditions)) {
            data["sortConditions"] = [];
            for (let item of this.sortConditions)
                data["sortConditions"].push(item.toJSON());
        }
        return data; 
    }

    clone(): QueryInput {
        const json = this.toJSON();
        let result = new QueryInput();
        result.init(json);
        return result;
    }
}

export interface IQueryInput {
    pageSize: number;
    skipCount: number;
    queryConditions: QueryCondition[] | undefined;
    sortConditions: SortCondition[] | undefined;
}

export class RoleDto implements IRoleDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isStatic: boolean;
    id: string | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isStatic = _data["isStatic"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isStatic: boolean;
    id: string | undefined;
}

export class RoleDtoPageResultDto implements IRoleDtoPageResultDto {
    items: RoleDto[] | undefined;
    total: number;

    constructor(data?: IRoleDtoPageResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): RoleDtoPageResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoPageResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }

    clone(): RoleDtoPageResultDto {
        const json = this.toJSON();
        let result = new RoleDtoPageResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoPageResultDto {
    items: RoleDto[] | undefined;
    total: number;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoListResultDto {
    items: RoleDto[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    entityDto: RoleDto;
    permissions: string[] | undefined;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityDto = _data["entityDto"] ? RoleDto.fromJS(_data["entityDto"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(item);
            }
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityDto"] = this.entityDto ? this.entityDto.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data; 
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    entityDto: RoleDto;
    permissions: string[] | undefined;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
    entityDto: RoleDto;
    permissions: string[] | undefined;

    constructor(data?: ICreateOrUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityDto = _data["entityDto"] ? RoleDto.fromJS(_data["entityDto"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityDto"] = this.entityDto ? this.entityDto.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data; 
    }

    clone(): CreateOrUpdateRoleInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateRoleInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateRoleInput {
    entityDto: RoleDto;
    permissions: string[] | undefined;
}

export class SampleEntity implements ISampleEntity {
    displayName: string | undefined;
    id: number;

    constructor(data?: ISampleEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SampleEntity {
        data = typeof data === 'object' ? data : {};
        let result = new SampleEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["id"] = this.id;
        return data; 
    }

    clone(): SampleEntity {
        const json = this.toJSON();
        let result = new SampleEntity();
        result.init(json);
        return result;
    }
}

export interface ISampleEntity {
    displayName: string | undefined;
    id: number;
}

export class MultiTenancyDto implements IMultiTenancyDto {
    isEnabled: boolean;
    name: string | undefined;
    displayName: string | undefined;

    constructor(data?: IMultiTenancyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): MultiTenancyDto {
        data = typeof data === 'object' ? data : {};
        let result = new MultiTenancyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone(): MultiTenancyDto {
        const json = this.toJSON();
        let result = new MultiTenancyDto();
        result.init(json);
        return result;
    }
}

export interface IMultiTenancyDto {
    isEnabled: boolean;
    name: string | undefined;
    displayName: string | undefined;
}

export class AuthDto implements IAuthDto {
    userId: string | undefined;
    userName: string | undefined;
    userNickName: string | undefined;
    allPermissions: string[] | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: IAuthDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.userNickName = _data["userNickName"];
            if (Array.isArray(_data["allPermissions"])) {
                this.allPermissions = [] as any;
                for (let item of _data["allPermissions"])
                    this.allPermissions.push(item);
            }
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): AuthDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["userNickName"] = this.userNickName;
        if (Array.isArray(this.allPermissions)) {
            data["allPermissions"] = [];
            for (let item of this.allPermissions)
                data["allPermissions"].push(item);
        }
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data; 
    }

    clone(): AuthDto {
        const json = this.toJSON();
        let result = new AuthDto();
        result.init(json);
        return result;
    }
}

export interface IAuthDto {
    userId: string | undefined;
    userName: string | undefined;
    userNickName: string | undefined;
    allPermissions: string[] | undefined;
    grantedPermissions: string[] | undefined;
}

export class LanguageInfoDto implements ILanguageInfoDto {
    culture: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    extra: string | undefined;
    texts: { [key: string]: string; } | undefined;

    constructor(data?: ILanguageInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.culture = _data["culture"];
            this.displayName = _data["displayName"];
            this.icon = _data["icon"];
            this.extra = _data["extra"];
            if (_data["texts"]) {
                this.texts = {} as any;
                for (let key in _data["texts"]) {
                    if (_data["texts"].hasOwnProperty(key))
                        this.texts[key] = _data["texts"][key];
                }
            }
        }
    }

    static fromJS(data: any): LanguageInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["culture"] = this.culture;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["extra"] = this.extra;
        if (this.texts) {
            data["texts"] = {};
            for (let key in this.texts) {
                if (this.texts.hasOwnProperty(key))
                    data["texts"][key] = this.texts[key];
            }
        }
        return data; 
    }

    clone(): LanguageInfoDto {
        const json = this.toJSON();
        let result = new LanguageInfoDto();
        result.init(json);
        return result;
    }
}

export interface ILanguageInfoDto {
    culture: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    extra: string | undefined;
    texts: { [key: string]: string; } | undefined;
}

export class LocalizationDto implements ILocalizationDto {
    defaultCulture: string | undefined;
    currentCulture: string | undefined;
    languages: LanguageInfoDto[] | undefined;

    constructor(data?: ILocalizationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultCulture = _data["defaultCulture"];
            this.currentCulture = _data["currentCulture"];
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages.push(LanguageInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizationDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultCulture"] = this.defaultCulture;
        data["currentCulture"] = this.currentCulture;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        return data; 
    }

    clone(): LocalizationDto {
        const json = this.toJSON();
        let result = new LocalizationDto();
        result.init(json);
        return result;
    }
}

export interface ILocalizationDto {
    defaultCulture: string | undefined;
    currentCulture: string | undefined;
    languages: LanguageInfoDto[] | undefined;
}

export class SessionDto implements ISessionDto {
    name: string | undefined;
    displayName: string | undefined;
    version: string | undefined;
    multiTenancy: MultiTenancyDto;
    auth: AuthDto;
    localization: LocalizationDto;
    menu: string | undefined;

    constructor(data?: ISessionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.version = _data["version"];
            this.multiTenancy = _data["multiTenancy"] ? MultiTenancyDto.fromJS(_data["multiTenancy"]) : <any>undefined;
            this.auth = _data["auth"] ? AuthDto.fromJS(_data["auth"]) : <any>undefined;
            this.localization = _data["localization"] ? LocalizationDto.fromJS(_data["localization"]) : <any>undefined;
            this.menu = _data["menu"];
        }
    }

    static fromJS(data: any): SessionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SessionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["version"] = this.version;
        data["multiTenancy"] = this.multiTenancy ? this.multiTenancy.toJSON() : <any>undefined;
        data["auth"] = this.auth ? this.auth.toJSON() : <any>undefined;
        data["localization"] = this.localization ? this.localization.toJSON() : <any>undefined;
        data["menu"] = this.menu;
        return data; 
    }

    clone(): SessionDto {
        const json = this.toJSON();
        let result = new SessionDto();
        result.init(json);
        return result;
    }
}

export interface ISessionDto {
    name: string | undefined;
    displayName: string | undefined;
    version: string | undefined;
    multiTenancy: MultiTenancyDto;
    auth: AuthDto;
    localization: LocalizationDto;
    menu: string | undefined;
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenantName: string | undefined;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantName = _data["tenantName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        return data; 
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenantName: string | undefined;
}

export enum TenantAvailabilityState {
    Available = <any>"Available",
    InActive = <any>"InActive",
    NotFound = <any>"NotFound",
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantName: string | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantName = _data["tenantName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantName"] = this.tenantName;
        return data; 
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantName: string | undefined;
}

export class TenantDto implements ITenantDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    connectionString: string | undefined;
    isStatic: boolean;
    isActive: boolean;
    id: string | undefined;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.connectionString = _data["connectionString"];
            this.isStatic = _data["isStatic"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["connectionString"] = this.connectionString;
        data["isStatic"] = this.isStatic;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    connectionString: string | undefined;
    isStatic: boolean;
    isActive: boolean;
    id: string | undefined;
}

export class TenantDtoPageResultDto implements ITenantDtoPageResultDto {
    items: TenantDto[] | undefined;
    total: number;

    constructor(data?: ITenantDtoPageResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): TenantDtoPageResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPageResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }

    clone(): TenantDtoPageResultDto {
        const json = this.toJSON();
        let result = new TenantDtoPageResultDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDtoPageResultDto {
    items: TenantDto[] | undefined;
    total: number;
}

export class CreateOrUpdateTenantInput implements ICreateOrUpdateTenantInput {
    adminUser: string | undefined;
    adminUserPassword: string | undefined;
    adminUserEmail: string | undefined;
    adminUserPhoneNumber: string | undefined;
    entityDto: TenantDto;

    constructor(data?: ICreateOrUpdateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adminUser = _data["adminUser"];
            this.adminUserPassword = _data["adminUserPassword"];
            this.adminUserEmail = _data["adminUserEmail"];
            this.adminUserPhoneNumber = _data["adminUserPhoneNumber"];
            this.entityDto = _data["entityDto"] ? TenantDto.fromJS(_data["entityDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateOrUpdateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminUser"] = this.adminUser;
        data["adminUserPassword"] = this.adminUserPassword;
        data["adminUserEmail"] = this.adminUserEmail;
        data["adminUserPhoneNumber"] = this.adminUserPhoneNumber;
        data["entityDto"] = this.entityDto ? this.entityDto.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateTenantInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateTenantInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTenantInput {
    adminUser: string | undefined;
    adminUserPassword: string | undefined;
    adminUserEmail: string | undefined;
    adminUserPhoneNumber: string | undefined;
    entityDto: TenantDto;
}

export class AuthenticateModelInput implements IAuthenticateModelInput {
    account: string | undefined;
    password: string | undefined;
    verificationCode: string | undefined;
    rememberClient: boolean;
    returnUrl: string | undefined;
    useCookie: boolean;
    useToken: boolean;

    constructor(data?: IAuthenticateModelInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.account = _data["account"];
            this.password = _data["password"];
            this.verificationCode = _data["verificationCode"];
            this.rememberClient = _data["rememberClient"];
            this.returnUrl = _data["returnUrl"];
            this.useCookie = _data["useCookie"];
            this.useToken = _data["useToken"];
        }
    }

    static fromJS(data: any): AuthenticateModelInput {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModelInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account;
        data["password"] = this.password;
        data["verificationCode"] = this.verificationCode;
        data["rememberClient"] = this.rememberClient;
        data["returnUrl"] = this.returnUrl;
        data["useCookie"] = this.useCookie;
        data["useToken"] = this.useToken;
        return data; 
    }

    clone(): AuthenticateModelInput {
        const json = this.toJSON();
        let result = new AuthenticateModelInput();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModelInput {
    account: string | undefined;
    password: string | undefined;
    verificationCode: string | undefined;
    rememberClient: boolean;
    returnUrl: string | undefined;
    useCookie: boolean;
    useToken: boolean;
}

export class AuthenticateResultDto implements IAuthenticateResultDto {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
    shouldResetPassword: boolean;
    passwordResetCode: string | undefined;
    returnUrl: string | undefined;
    waitingForActivation: boolean;

    constructor(data?: IAuthenticateResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
            this.shouldResetPassword = _data["shouldResetPassword"];
            this.passwordResetCode = _data["passwordResetCode"];
            this.returnUrl = _data["returnUrl"];
            this.waitingForActivation = _data["waitingForActivation"];
        }
    }

    static fromJS(data: any): AuthenticateResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["returnUrl"] = this.returnUrl;
        data["waitingForActivation"] = this.waitingForActivation;
        return data; 
    }

    clone(): AuthenticateResultDto {
        const json = this.toJSON();
        let result = new AuthenticateResultDto();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultDto {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
    shouldResetPassword: boolean;
    passwordResetCode: string | undefined;
    returnUrl: string | undefined;
    waitingForActivation: boolean;
}

export class UserDto implements IUserDto {
    userName: string | undefined;
    nickname: string | undefined;
    phoneNumber: string | undefined;
    phoneNumberConfirmed: boolean;
    email: string | undefined;
    emailConfirmed: boolean;
    lockoutEnabled: boolean;
    isActive: boolean;
    twoFactorEnabled: boolean;
    isStatic: boolean;
    id: string | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.nickname = _data["nickname"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.email = _data["email"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.isActive = _data["isActive"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.isStatic = _data["isStatic"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["nickname"] = this.nickname;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["email"] = this.email;
        data["emailConfirmed"] = this.emailConfirmed;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["isActive"] = this.isActive;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["isStatic"] = this.isStatic;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    userName: string | undefined;
    nickname: string | undefined;
    phoneNumber: string | undefined;
    phoneNumberConfirmed: boolean;
    email: string | undefined;
    emailConfirmed: boolean;
    lockoutEnabled: boolean;
    isActive: boolean;
    twoFactorEnabled: boolean;
    isStatic: boolean;
    id: string | undefined;
}

export class UserDtoPageResultDto implements IUserDtoPageResultDto {
    items: UserDto[] | undefined;
    total: number;

    constructor(data?: IUserDtoPageResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): UserDtoPageResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPageResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }

    clone(): UserDtoPageResultDto {
        const json = this.toJSON();
        let result = new UserDtoPageResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserDtoPageResultDto {
    items: UserDto[] | undefined;
    total: number;
}

export class UserEditDto implements IUserEditDto {
    entityDto: UserDto;
    roles: string[] | undefined;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityDto = _data["entityDto"] ? UserDto.fromJS(_data["entityDto"]) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles.push(item);
            }
        }
    }

    static fromJS(data: any): UserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityDto"] = this.entityDto ? this.entityDto.toJSON() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }

    clone(): UserEditDto {
        const json = this.toJSON();
        let result = new UserEditDto();
        result.init(json);
        return result;
    }
}

export interface IUserEditDto {
    entityDto: UserDto;
    roles: string[] | undefined;
}

export class CreateOrEditUserInput implements ICreateOrEditUserInput {
    password: string | undefined;
    entityDto: UserDto;
    roles: string[] | undefined;

    constructor(data?: ICreateOrEditUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
            this.entityDto = _data["entityDto"] ? UserDto.fromJS(_data["entityDto"]) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrEditUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["entityDto"] = this.entityDto ? this.entityDto.toJSON() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }

    clone(): CreateOrEditUserInput {
        const json = this.toJSON();
        let result = new CreateOrEditUserInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditUserInput {
    password: string | undefined;
    entityDto: UserDto;
    roles: string[] | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}